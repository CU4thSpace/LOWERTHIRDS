<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://use.typekit.net/paf7uxj.css">
<title>HTML Lower Third – BrightSign (Google Sheets)</title>
<style>
/* ===== GLOBAL ===== */
html, body {
  width: 1920px;
  height: 1080px;
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #00FF00; /* ATEM chroma key */
  font-family: "gill-sans-nova-condensed", sans-serif;
}

/* ===== SAFE FRAME CONTAINER ===== */
.event-container {
  position: relative;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
}

/* ===== LOWER THIRD BLOCK ===== */
#lowerthird {
  position: absolute;
  left: 5.2%;
  bottom: 9.3%;
  max-width: 72.9%;
  opacity: 0;
  transform: translateY(40px);
  transition: opacity 0.35s ease, transform 0.35s ease;
  z-index: 10;
}

#lowerthird.show {
  opacity: 1;
  transform: translateY(0);
}

/* ===== TEXT STYLES ===== */
.name {
  font-size: clamp(2rem, 7.5vw, 7.5rem);
  font-weight: bold;
  line-height: 1;
  color: #ccc;
  opacity: 1.0;
  word-break: keep-all;
  overflow-wrap: break-word;
  margin-bottom: 0.2em;
}

.title {
  font-size: clamp(1rem, 3.2vw, 3.2rem);
  font-weight: 100;
  line-height: 1;
  opacity: 0.9;
  color: #ccc;
}

/* ===== UTILITY ===== */
.no-break {
  white-space: nowrap;
  word-break: keep-all;
}

/* ===== DEBUG INDICATOR ===== */
#debug {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.8);
  color: #0f0;
  padding: 10px;
  font-family: monospace;
  font-size: 14px;
  max-width: 600px;
  z-index: 1000;
  white-space: pre-wrap;
  word-break: break-all;
}
</style>
</head>
<body>
<div id="debug">Loading...</div>
<div class="event-container">
  <div id="lowerthird">
    <div class="name" id="name"></div>
    <div class="title" id="title"></div>
  </div>
</div>

<script>
/* ===== CONFIG ===== */
const CSV_URL   = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTBAMH4McS3-OHHgVUVqk_pt6WOhe0Jpp5ON2PbzyvGpGlF8kRHyt6JZlIQ0eN99kLkbpxl4la0ceWc/pub?output=csv";
const PROXY_URL = "https://corsproxy.io/?" + encodeURIComponent(CSV_URL);

/* ===== STATE ===== */
let entries = [];
let index   = -1;

const lt      = document.getElementById("lowerthird");
const nameEl  = document.getElementById("name");
const titleEl = document.getElementById("title");
const debugEl = document.getElementById("debug");

/* ===== DEBUG ===== */
function debug(msg) {
  console.log(msg);
  debugEl.textContent += '\n' + msg;
}

/* ===== CSV PARSER ===== */
function parseCSV(text) {
  const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
  if (lines.length < 2) return [];

  function parseLine(line) {
    const fields = [];
    let field = '', inQ = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQ && line[i+1] === '"') { field += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === ',' && !inQ) {
        fields.push(field.trim()); field = '';
      } else {
        field += ch;
      }
    }
    fields.push(field.trim());
    return fields;
  }

  const headers = parseLine(lines[0]).map(h => h.toLowerCase().trim());
  debug('Headers detected: ' + JSON.stringify(headers));

  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    const vals = parseLine(line);
    const obj  = {};
    headers.forEach((h, idx) => { obj[h] = vals[idx] !== undefined ? vals[idx] : ''; });
    rows.push(obj);
  }
  return rows;
}

/* ===== MAP ROWS TO ENTRIES ===== */
function rowsToEntries(rows) {
  if (!rows.length) return [];
  const keys = Object.keys(rows[0]);

  // Find best column matches (case-insensitive)
  const nameKey  = keys.find(k => /^names?$/i.test(k))  || keys[0];
  const titleKey = keys.find(k => /^(title|role|position|subtitle|org|organization)$/i.test(k)) || keys[1] || '';

  debug('Using name col: "' + nameKey + '"  title col: "' + (titleKey || 'none') + '"');

  return rows
    .map(r => ({ name: (r[nameKey] || '').trim(), title: (r[titleKey] || '').trim() }))
    .filter(e => e.name !== '');
}

/* ===== FETCH WITH PROXY FALLBACK ===== */
async function fetchCSV(url, label) {
  debug('Trying ' + label + '...');
  const r = await fetch(url);
  debug(label + ' → status ' + r.status + ' ' + r.statusText);
  if (!r.ok) throw new Error('HTTP ' + r.status);
  const text = await r.text();
  debug('Received ' + text.length + ' bytes');
  debug('Preview: ' + text.slice(0, 120).replace(/\n/g, '↵'));
  return text;
}

async function loadNames() {
  let csvText = null;

  // 1. Try direct fetch (works fine on HTTPS like GitHub Pages)
  try {
    csvText = await fetchCSV(CSV_URL, 'direct');
  } catch(e) {
    debug('Direct failed: ' + e.message);
  }

  // 2. CORS proxy fallback
  if (!csvText) {
    try {
      csvText = await fetchCSV(PROXY_URL, 'proxy');
    } catch(e) {
      debug('Proxy failed: ' + e.message);
    }
  }

  if (!csvText) {
    debug('ALL FETCHES FAILED');
    debug('Make sure the sheet is published: File → Share → Publish to web → CSV');
    entries = [{ name: "Sheet", title: "Didn't Load!" }];
    return;
  }

  const rows = parseCSV(csvText);
  debug('Rows parsed: ' + rows.length);

  entries = rowsToEntries(rows);
  debug('Entries ready: ' + entries.length);

  if (entries.length > 0) {
    debug('First: ' + JSON.stringify(entries[0]));
    setTimeout(() => { debugEl.style.display = 'none'; }, 4000);
  } else {
    debug('0 entries — are your column headers named "name" and "title"?');
  }
}

/* ===== DISPLAY ===== */
function showEntry(i) {
  if (!entries.length) { debug('No entries!'); return; }
  index = (i + entries.length) % entries.length;
  nameEl.textContent  = entries[index].name;
  titleEl.textContent = entries[index].title || '';
  lt.classList.add("show");
}

function nextEntry() { showEntry(index + 1); }
function prevEntry() { showEntry(index - 1); }
function hideEntry() { lt.classList.remove("show"); }

/* ===== KEYBOARD =====
   →  Next     ←  Previous     ↓  Hide     Shift+R  Reload
*/
document.addEventListener("keydown", e => {
  switch (e.key) {
    case "ArrowRight": nextEntry();      break;
    case "ArrowLeft":  prevEntry();      break;
    case "ArrowDown":  hideEntry();      break;
    case "R": case "r":
      if (e.shiftKey) location.reload();
      break;
  }
});

/* ===== INIT ===== */
loadNames().then(() => hideEntry());
</script>
</body>
</html>
